#!/usr/bin/env python3.10

import argparse
import ast, os, glob
from io import IOBase

from xdsl.ir import MLContext
from xdsl.dialects.builtin import ModuleOp

from psy.psy_ir_to_fir import LowerPsyIR
from psy.apply_stencil import ApplyStencilAnalysis
from psy.extract_stencil import ExtractStencil
from psy.rewrite_fir_to_standard import RewriteFIRToStandard

from psy.dialects.psy_ir import psyIR
from psy.dialects.psy_stencil import psyStencil
from ftn.dialects.fir import FIR
from util.semantic_error import SemanticError

from pathlib import Path

from typing import Callable, Dict, List

from xdsl.xdsl_opt_main import xDSLOptMain

class PsyOptMain(xDSLOptMain):

    def register_all_passes(self):
        super().register_all_passes()
        self.register_pass(ApplyStencilAnalysis)
        self.register_pass(LowerPsyIR)
        self.register_pass(ExtractStencil)
        self.register_pass(RewriteFIRToStandard)

    def register_all_targets(self):
        super().register_all_targets()
        self.available_targets['both'] = self.available_targets['xdsl']

    def setup_pipeline(self):
      super().setup_pipeline()

    def register_all_dialects(self):
        super().register_all_dialects()
        """Register all dialects that can be used."""
        self.ctx.register_dialect(psyIR)
        self.ctx.register_dialect(psyStencil)
        self.ctx.register_dialect(FIR)        

    @staticmethod
    def get_passes_as_dict(
    ) -> Dict[str, Callable[[MLContext, ModuleOp], None]]:
        """Add all passes that can be called by psy-opt in a dictionary."""

        pass_dictionary = {}

        passes = PsyOptMain.passes_native

        for pass_function in passes:
            pass_dictionary[pass_function.__name__.replace(
                "_", "-")] = pass_function

        return pass_dictionary

    def get_passes_as_list(native=False, integrated=False) -> List[str]:
        """Add all passes that can be called by psy-opt in a dictionary."""

        pass_list = []

        passes = PsyOptMain.passes_native

        for pass_function in passes:
            pass_list.append(pass_function.__name__.replace("_", "-"))

        return pass_list

    def register_all_frontends(self):
        super().register_all_frontends()

def _output_modules_to_file_for_target(module, target, psy_main):
  psy_main.args.target=target
  i=0
  for op in module.regions[0].blocks[0].ops:
    if isinstance(op, ModuleOp):
      module_contents=psy_main.output_resulting_program(op)
      f = open("generated/module_"+str(i)+"."+target, "w")
      f.write(module_contents)
      f.close()
      i+=1

def _empty_generate_dir():
  if not os.path.isdir("generated"):
      Path("generated").mkdir(parents=True, exist_ok=True)

  files = glob.glob('generated/*')
  for f in files:
    os.remove(f)

def __main__():
    psy_main = PsyOptMain()

    try:
        module = psy_main.parse_input()
        psy_main.apply_passes(module)
    except SyntaxError as e:
        print(e.get_message())
        exit(0)
    except SemanticError as e:
        print("Semantic error: %s" % str(e))
        exit(0)

    _empty_generate_dir()

    if psy_main.args.target != "both":
      contents = psy_main.output_resulting_program(module)
      psy_main.print_to_output_stream(contents)

      _output_modules_to_file_for_target(module, psy_main.args.target, psy_main)
    else:
      _output_modules_to_file_for_target(module, "xdsl", psy_main)
      _output_modules_to_file_for_target(module, "mlir", psy_main)



if __name__ == "__main__":
    __main__()
